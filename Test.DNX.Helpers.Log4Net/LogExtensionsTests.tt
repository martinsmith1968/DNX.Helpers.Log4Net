<#@ template debug="false" hostspecific="True" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="MultipleOutputHelper.ttinclude" #>
<# // http://mariusbancila.ro/blog/2012/09/03/t4-lessons-learned/ #>
<# var manager = Manager.Create(Host, GenerationEnvironment); #>
<#
var types = new Dictionary<string, string>()
{
	{ "Debug", "Debug" },
	{ "Info", "Info" },
	{ "Warn", "Warn" },
	{ "Error", "Error" },
	{ "Fatal", "Fatal" },
}; #>
<# manager.StartHeader(); #>
// Code generated by a Template
using System;
using DNX.Helpers.Log4Net;
using log4net;
using Moq;
using NUnit.Framework;

namespace Test.DNX.Helpers.Log4Net
{
<# manager.EndBlock(); #>
<#
foreach (var kvp in types)
{
	var typeName = kvp.Value;
	var typeDesc = kvp.Key;
	var fileName = string.Format("LogExtensionsTests.{0}.generated.cs", typeDesc);

	manager.StartNewFile(fileName);
#>
    [TestFixture]
    public class LogExtensionsTests_<#= typeName #>
    {
        [Test]
        public void <#= typeName #>Func_MessageText_<#= typeName #>NotEnabled_TextNotEvaluated()
        {
            // Arrange
            var textCalled = false;

            var logger = new Mock<ILog>(MockBehavior.Strict);
            logger.Setup(l => l.Is<#= typeName #>Enabled).Returns(false);
            logger.Setup(l => l.<#= typeName #>(It.IsAny<object>()));
            logger.Setup(l => l.<#= typeName #>(It.IsAny<object>(), It.IsAny<Exception>()));

            Func<string> getText = () =>
            {
                textCalled = true;

                return "Some text";
            };

            // Act
            logger.Object.<#= typeName #>Func(getText);

            // Assert
            Assert.IsFalse(textCalled);
            logger.Verify(l => l.<#= typeName #>(It.IsAny<object>()), Times.Never());
            logger.Verify(l => l.<#= typeName #>(It.IsAny<object>(), It.IsAny<Exception>()), Times.Never());
        }

        [Test]
        public void <#= typeName #>Func_MessageText_<#= typeName #>Enabled_TextEvaluated()
        {
            // Arrange
            var textCalled = false;

            var logger = new Mock<ILog>(MockBehavior.Strict);
            logger.Setup(l => l.Is<#= typeName #>Enabled).Returns(true);
            logger.Setup(l => l.<#= typeName #>(It.IsAny<object>()));
            logger.Setup(l => l.<#= typeName #>(It.IsAny<object>(), It.IsAny<Exception>()));

            Func<string> getText = () =>
            {
                textCalled = true;

                return "Some text";
            };

            // Act
            logger.Object.<#= typeName #>Func(getText);

            // Assert
            Assert.IsTrue(textCalled);
            logger.Verify(l => l.<#= typeName #>(It.IsAny<object>()), Times.Once());
            logger.Verify(l => l.<#= typeName #>(It.IsAny<object>(), It.IsAny<Exception>()), Times.Never());
        }

        [Test]
        public void <#= typeName #>Func_MessageText_<#= typeName #>NotEnabled_TextNotEvaluated_AnonymousFunc()
        {
            // Arrange
            var textCalled = false;

            var logger = new Mock<ILog>(MockBehavior.Strict);
            logger.Setup(l => l.Is<#= typeName #>Enabled).Returns(false);
            logger.Setup(l => l.<#= typeName #>(It.IsAny<object>()));
            logger.Setup(l => l.<#= typeName #>(It.IsAny<object>(), It.IsAny<Exception>()));

            Func<int> getNumber = () =>
            {
                textCalled = true;

                return DateTime.UtcNow.Millisecond;
            };

            // Act
            logger.Object.<#= typeName #>Func(() => string.Format("Value: {0}", getNumber()));

            // Assert
            Assert.IsFalse(textCalled);
            logger.Verify(l => l.<#= typeName #>(It.IsAny<object>()), Times.Never());
            logger.Verify(l => l.<#= typeName #>(It.IsAny<object>(), It.IsAny<Exception>()), Times.Never());
        }

        [Test]
        public void <#= typeName #>Func_MessageText_<#= typeName #>Enabled_TextEvaluated_AnonymousFunc()
        {
            // Arrange
            var textCalled = false;

            var logger = new Mock<ILog>(MockBehavior.Strict);
            logger.Setup(l => l.Is<#= typeName #>Enabled).Returns(true);
            logger.Setup(l => l.<#= typeName #>(It.IsAny<object>()));
            logger.Setup(l => l.<#= typeName #>(It.IsAny<object>(), It.IsAny<Exception>()));

            Func<int> getNumber = () =>
            {
                textCalled = true;

                return DateTime.UtcNow.Millisecond;
            };

            // Act
            logger.Object.<#= typeName #>Func(() => string.Format("Value: {0}", getNumber()));

            // Assert
            Assert.IsTrue(textCalled);
            logger.Verify(l => l.<#= typeName #>(It.IsAny<object>()), Times.Once());
            logger.Verify(l => l.<#= typeName #>(It.IsAny<object>(), It.IsAny<Exception>()), Times.Never());
        }

        [Test]
        public void <#= typeName #>Func_MessageTextAndException_<#= typeName #>NotEnabled_TextAndExceptionNotEvaluated()
        {
            // Arrange
            var textCalled = false;
            var exceptionCalled = false;

            var logger = new Mock<ILog>(MockBehavior.Strict);
            logger.Setup(l => l.Is<#= typeName #>Enabled).Returns(false);
            logger.Setup(l => l.<#= typeName #>(It.IsAny<object>()));
            logger.Setup(l => l.<#= typeName #>(It.IsAny<object>(), It.IsAny<Exception>()));

            Func<string> getText = () =>
            {
                textCalled = true;

                return "Some text";
            };

            Func<Exception> getException = () =>
            {
                exceptionCalled = true;

                return new Exception();
            };

            // Act
            logger.Object.<#= typeName #>Func(getText, getException);

            // Assert
            Assert.IsFalse(textCalled);
            Assert.IsFalse(exceptionCalled);
            logger.Verify(l => l.<#= typeName #>(It.IsAny<object>()), Times.Never());
            logger.Verify(l => l.<#= typeName #>(It.IsAny<object>(), It.IsAny<Exception>()), Times.Never());
        }

        [Test]
        public void <#= typeName #>Func_MessageTextAndException_<#= typeName #>Enabled_TextAndExceptionEvaluated()
        {
            // Arrange
            var textCalled = false;
            var exceptionCalled = false;

            var logger = new Mock<ILog>(MockBehavior.Strict);
            logger.Setup(l => l.Is<#= typeName #>Enabled).Returns(true);
            logger.Setup(l => l.<#= typeName #>(It.IsAny<object>()));
            logger.Setup(l => l.<#= typeName #>(It.IsAny<object>(), It.IsAny<Exception>()));

            Func<string> getText = () =>
            {
                textCalled = true;

                return "Some text";
            };

            Func<Exception> getException = () =>
            {
                exceptionCalled = true;

                return new Exception();
            };

            // Act
            logger.Object.<#= typeName #>Func(getText, getException);

            // Assert
            Assert.IsTrue(textCalled);
            Assert.IsTrue(exceptionCalled);
            logger.Verify(l => l.<#= typeName #>(It.IsAny<object>()), Times.Never());
            logger.Verify(l => l.<#= typeName #>(It.IsAny<object>(), It.IsAny<Exception>()), Times.Once());
        }

        [Test]
        public void <#= typeName #>Func_MessageTextAndException_<#= typeName #>NotEnabled_TextAndExceptionNotEvaluated_AnonymousFunc()
        {
            // Arrange
            var textCalled = false;
            var exceptionCalled = false;

            var logger = new Mock<ILog>(MockBehavior.Strict);
            logger.Setup(l => l.Is<#= typeName #>Enabled).Returns(false);
            logger.Setup(l => l.<#= typeName #>(It.IsAny<object>()));
            logger.Setup(l => l.<#= typeName #>(It.IsAny<object>(), It.IsAny<Exception>()));

            Func<int> getNumber = () =>
            {
                textCalled = true;

                return DateTime.UtcNow.Millisecond;
            };

            Func<Exception> getException = () =>
            {
                exceptionCalled = true;

                return new Exception();
            };

            // Act
            logger.Object.<#= typeName #>Func(() => string.Format("Value: {0}", getNumber()), () => getException());

            // Assert
            Assert.IsFalse(textCalled);
            Assert.IsFalse(exceptionCalled);
            logger.Verify(l => l.<#= typeName #>(It.IsAny<object>()), Times.Never());
            logger.Verify(l => l.<#= typeName #>(It.IsAny<object>(), It.IsAny<Exception>()), Times.Never());
        }

        [Test]
        public void <#= typeName #>Func_MessageTextAndException_<#= typeName #>Enabled_TextAndExceptionEvaluated_AnonymousFunc()
        {
            // Arrange
            var textCalled = false;
            var exceptionCalled = false;

            var logger = new Mock<ILog>(MockBehavior.Strict);
            logger.Setup(l => l.Is<#= typeName #>Enabled).Returns(true);
            logger.Setup(l => l.<#= typeName #>(It.IsAny<object>()));
            logger.Setup(l => l.<#= typeName #>(It.IsAny<object>(), It.IsAny<Exception>()));

            Func<int> getNumber = () =>
            {
                textCalled = true;

                return DateTime.UtcNow.Millisecond;
            };

            Func<Exception> getException = () =>
            {
                exceptionCalled = true;

                return new Exception();
            };

            // Act
            logger.Object.<#= typeName #>Func(() => string.Format("Value: {0}", getNumber()), () => getException());

            // Assert
            Assert.IsTrue(textCalled);
            Assert.IsTrue(exceptionCalled);
            logger.Verify(l => l.<#= typeName #>(It.IsAny<object>()), Times.Never());
            logger.Verify(l => l.<#= typeName #>(It.IsAny<object>(), It.IsAny<Exception>()), Times.Once());
        }
	}
<#	manager.EndBlock();
} #>
<# manager.StartFooter(); #>
}
<# manager.EndBlock(); #>

<# manager.Process(true); #>
